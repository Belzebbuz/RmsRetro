// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "";

export enum RoomOperationTypes {
  StartTimer = 0,
  PauseTimer = 1,
  StartVoting = 2,
  StopVoting = 3,
  AddCard = 4,
  UNRECOGNIZED = -1,
}

export enum CardOperationTypes {
  EditCard = 0,
  CombineCards = 1,
  DeleteCard = 2,
  AddLikeCard = 3,
  RemoveLikeCard = 4,
  MoveCard = 5,
  UNRECOGNIZED = -1,
}

export interface ActivateUserResponse {
  userId: string;
}

export interface GetUserStatusRequest {
}

export interface GetUserStatusResponse {
  isActive: boolean;
}

export interface ConnectRequest {
  roomId: string;
}

export interface GetRoomInfoRequest {
  roomId: string;
}

export interface GetRoomInfoResponse {
  info: RoomInfo | undefined;
}

export interface InitRoomRequest {
  roomTemplateId: string;
}

export interface InitRoomResponse {
  roomId: string;
}

export interface RoomInfo {
  roomId: string;
  availableOperations: RoomOperationTypes[];
  columns: RoomColumn[];
  version: number;
  isVoteStarted: boolean;
  votesCount: number;
  votesLeft: number;
}

export interface RoomColumn {
  id: string;
  columnName: string;
  color: string;
  order: number;
  cards: TextCard[];
}

export interface TextCard {
  id: string;
  text: string;
  order: number;
  likesCount: number;
  isUserLiked: boolean;
  availableOperations: CardOperationTypes[];
}

export interface InvokeRoomOperationRequest {
  roomId: string;
  startTimer?: StartTimerOperation | undefined;
  pauseTimer?: PauseTimerOperation | undefined;
  startVoting?: StartVotingOperation | undefined;
  stopVoting?: StopVotingOperation | undefined;
  add?: AddCardOperation | undefined;
  edit?: EditCardOperation | undefined;
  combine?: CombineCardsOperation | undefined;
  delete?: DeleteCardOperation | undefined;
  addLike?: AddLikeCardOperation | undefined;
  removeLike?: RemoveLikeCardOperation | undefined;
  move?: MoveCardOperation | undefined;
}

export interface StartTimerOperation {
  minutes: number;
}

export interface PauseTimerOperation {
}

export interface StartVotingOperation {
  votesPerUser: number;
  timerMinutes: number;
}

export interface StopVotingOperation {
}

export interface AddCardOperation {
  columnId: string;
  text: string;
}

export interface EditCardOperation {
  cardId: string;
  text: string;
}

export interface CombineCardsOperation {
  deleteCardId: string;
  targetCardId: string;
}

export interface DeleteCardOperation {
  cardId: string;
}

export interface AddLikeCardOperation {
  cardId: string;
}

export interface MoveCardOperation {
  cardId: string;
  newColumnId: string;
  newOrderId: number;
}

export interface ChangeCardOrderEvent {
  cardId: string;
  newOrderNumber: string;
}

export interface RemoveLikeCardOperation {
  cardId: string;
}

export interface GetRoomTemplatesResponse {
  templateIds: string[];
}

function createBaseActivateUserResponse(): ActivateUserResponse {
  return { userId: "" };
}

export const ActivateUserResponse: MessageFns<ActivateUserResponse> = {
  encode(message: ActivateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ActivateUserResponse>): ActivateUserResponse {
    return ActivateUserResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActivateUserResponse>): ActivateUserResponse {
    const message = createBaseActivateUserResponse();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserStatusRequest(): GetUserStatusRequest {
  return {};
}

export const GetUserStatusRequest: MessageFns<GetUserStatusRequest> = {
  encode(_: GetUserStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetUserStatusRequest>): GetUserStatusRequest {
    return GetUserStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetUserStatusRequest>): GetUserStatusRequest {
    const message = createBaseGetUserStatusRequest();
    return message;
  },
};

function createBaseGetUserStatusResponse(): GetUserStatusResponse {
  return { isActive: false };
}

export const GetUserStatusResponse: MessageFns<GetUserStatusResponse> = {
  encode(message: GetUserStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetUserStatusResponse>): GetUserStatusResponse {
    return GetUserStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetUserStatusResponse>): GetUserStatusResponse {
    const message = createBaseGetUserStatusResponse();
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseConnectRequest(): ConnectRequest {
  return { roomId: "" };
}

export const ConnectRequest: MessageFns<ConnectRequest> = {
  encode(message: ConnectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ConnectRequest>): ConnectRequest {
    return ConnectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectRequest>): ConnectRequest {
    const message = createBaseConnectRequest();
    message.roomId = object.roomId ?? "";
    return message;
  },
};

function createBaseGetRoomInfoRequest(): GetRoomInfoRequest {
  return { roomId: "" };
}

export const GetRoomInfoRequest: MessageFns<GetRoomInfoRequest> = {
  encode(message: GetRoomInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoomInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoomInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetRoomInfoRequest>): GetRoomInfoRequest {
    return GetRoomInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRoomInfoRequest>): GetRoomInfoRequest {
    const message = createBaseGetRoomInfoRequest();
    message.roomId = object.roomId ?? "";
    return message;
  },
};

function createBaseGetRoomInfoResponse(): GetRoomInfoResponse {
  return { info: undefined };
}

export const GetRoomInfoResponse: MessageFns<GetRoomInfoResponse> = {
  encode(message: GetRoomInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.info !== undefined) {
      RoomInfo.encode(message.info, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoomInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoomInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.info = RoomInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetRoomInfoResponse>): GetRoomInfoResponse {
    return GetRoomInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRoomInfoResponse>): GetRoomInfoResponse {
    const message = createBaseGetRoomInfoResponse();
    message.info = (object.info !== undefined && object.info !== null) ? RoomInfo.fromPartial(object.info) : undefined;
    return message;
  },
};

function createBaseInitRoomRequest(): InitRoomRequest {
  return { roomTemplateId: "" };
}

export const InitRoomRequest: MessageFns<InitRoomRequest> = {
  encode(message: InitRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomTemplateId !== "") {
      writer.uint32(10).string(message.roomTemplateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomTemplateId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InitRoomRequest>): InitRoomRequest {
    return InitRoomRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitRoomRequest>): InitRoomRequest {
    const message = createBaseInitRoomRequest();
    message.roomTemplateId = object.roomTemplateId ?? "";
    return message;
  },
};

function createBaseInitRoomResponse(): InitRoomResponse {
  return { roomId: "" };
}

export const InitRoomResponse: MessageFns<InitRoomResponse> = {
  encode(message: InitRoomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitRoomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InitRoomResponse>): InitRoomResponse {
    return InitRoomResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitRoomResponse>): InitRoomResponse {
    const message = createBaseInitRoomResponse();
    message.roomId = object.roomId ?? "";
    return message;
  },
};

function createBaseRoomInfo(): RoomInfo {
  return {
    roomId: "",
    availableOperations: [],
    columns: [],
    version: 0,
    isVoteStarted: false,
    votesCount: 0,
    votesLeft: 0,
  };
}

export const RoomInfo: MessageFns<RoomInfo> = {
  encode(message: RoomInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    writer.uint32(18).fork();
    for (const v of message.availableOperations) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.columns) {
      RoomColumn.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.version !== 0) {
      writer.uint32(32).int32(message.version);
    }
    if (message.isVoteStarted !== false) {
      writer.uint32(40).bool(message.isVoteStarted);
    }
    if (message.votesCount !== 0) {
      writer.uint32(48).int32(message.votesCount);
    }
    if (message.votesLeft !== 0) {
      writer.uint32(56).int32(message.votesLeft);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.availableOperations.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableOperations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.columns.push(RoomColumn.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isVoteStarted = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.votesCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.votesLeft = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RoomInfo>): RoomInfo {
    return RoomInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomInfo>): RoomInfo {
    const message = createBaseRoomInfo();
    message.roomId = object.roomId ?? "";
    message.availableOperations = object.availableOperations?.map((e) => e) || [];
    message.columns = object.columns?.map((e) => RoomColumn.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    message.isVoteStarted = object.isVoteStarted ?? false;
    message.votesCount = object.votesCount ?? 0;
    message.votesLeft = object.votesLeft ?? 0;
    return message;
  },
};

function createBaseRoomColumn(): RoomColumn {
  return { id: "", columnName: "", color: "", order: 0, cards: [] };
}

export const RoomColumn: MessageFns<RoomColumn> = {
  encode(message: RoomColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.columnName !== "") {
      writer.uint32(26).string(message.columnName);
    }
    if (message.color !== "") {
      writer.uint32(34).string(message.color);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    for (const v of message.cards) {
      TextCard.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.columnName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cards.push(TextCard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RoomColumn>): RoomColumn {
    return RoomColumn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomColumn>): RoomColumn {
    const message = createBaseRoomColumn();
    message.id = object.id ?? "";
    message.columnName = object.columnName ?? "";
    message.color = object.color ?? "";
    message.order = object.order ?? 0;
    message.cards = object.cards?.map((e) => TextCard.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTextCard(): TextCard {
  return { id: "", text: "", order: 0, likesCount: 0, isUserLiked: false, availableOperations: [] };
}

export const TextCard: MessageFns<TextCard> = {
  encode(message: TextCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.order !== 0) {
      writer.uint32(24).int32(message.order);
    }
    if (message.likesCount !== 0) {
      writer.uint32(32).int32(message.likesCount);
    }
    if (message.isUserLiked !== false) {
      writer.uint32(40).bool(message.isUserLiked);
    }
    writer.uint32(50).fork();
    for (const v of message.availableOperations) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.likesCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isUserLiked = reader.bool();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.availableOperations.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableOperations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TextCard>): TextCard {
    return TextCard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextCard>): TextCard {
    const message = createBaseTextCard();
    message.id = object.id ?? "";
    message.text = object.text ?? "";
    message.order = object.order ?? 0;
    message.likesCount = object.likesCount ?? 0;
    message.isUserLiked = object.isUserLiked ?? false;
    message.availableOperations = object.availableOperations?.map((e) => e) || [];
    return message;
  },
};

function createBaseInvokeRoomOperationRequest(): InvokeRoomOperationRequest {
  return {
    roomId: "",
    startTimer: undefined,
    pauseTimer: undefined,
    startVoting: undefined,
    stopVoting: undefined,
    add: undefined,
    edit: undefined,
    combine: undefined,
    delete: undefined,
    addLike: undefined,
    removeLike: undefined,
    move: undefined,
  };
}

export const InvokeRoomOperationRequest: MessageFns<InvokeRoomOperationRequest> = {
  encode(message: InvokeRoomOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.startTimer !== undefined) {
      StartTimerOperation.encode(message.startTimer, writer.uint32(18).fork()).join();
    }
    if (message.pauseTimer !== undefined) {
      PauseTimerOperation.encode(message.pauseTimer, writer.uint32(26).fork()).join();
    }
    if (message.startVoting !== undefined) {
      StartVotingOperation.encode(message.startVoting, writer.uint32(34).fork()).join();
    }
    if (message.stopVoting !== undefined) {
      StopVotingOperation.encode(message.stopVoting, writer.uint32(42).fork()).join();
    }
    if (message.add !== undefined) {
      AddCardOperation.encode(message.add, writer.uint32(58).fork()).join();
    }
    if (message.edit !== undefined) {
      EditCardOperation.encode(message.edit, writer.uint32(66).fork()).join();
    }
    if (message.combine !== undefined) {
      CombineCardsOperation.encode(message.combine, writer.uint32(74).fork()).join();
    }
    if (message.delete !== undefined) {
      DeleteCardOperation.encode(message.delete, writer.uint32(82).fork()).join();
    }
    if (message.addLike !== undefined) {
      AddLikeCardOperation.encode(message.addLike, writer.uint32(90).fork()).join();
    }
    if (message.removeLike !== undefined) {
      RemoveLikeCardOperation.encode(message.removeLike, writer.uint32(98).fork()).join();
    }
    if (message.move !== undefined) {
      MoveCardOperation.encode(message.move, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvokeRoomOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeRoomOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startTimer = StartTimerOperation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pauseTimer = PauseTimerOperation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startVoting = StartVotingOperation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stopVoting = StopVotingOperation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.add = AddCardOperation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.edit = EditCardOperation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.combine = CombineCardsOperation.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.delete = DeleteCardOperation.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.addLike = AddLikeCardOperation.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.removeLike = RemoveLikeCardOperation.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.move = MoveCardOperation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InvokeRoomOperationRequest>): InvokeRoomOperationRequest {
    return InvokeRoomOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeRoomOperationRequest>): InvokeRoomOperationRequest {
    const message = createBaseInvokeRoomOperationRequest();
    message.roomId = object.roomId ?? "";
    message.startTimer = (object.startTimer !== undefined && object.startTimer !== null)
      ? StartTimerOperation.fromPartial(object.startTimer)
      : undefined;
    message.pauseTimer = (object.pauseTimer !== undefined && object.pauseTimer !== null)
      ? PauseTimerOperation.fromPartial(object.pauseTimer)
      : undefined;
    message.startVoting = (object.startVoting !== undefined && object.startVoting !== null)
      ? StartVotingOperation.fromPartial(object.startVoting)
      : undefined;
    message.stopVoting = (object.stopVoting !== undefined && object.stopVoting !== null)
      ? StopVotingOperation.fromPartial(object.stopVoting)
      : undefined;
    message.add = (object.add !== undefined && object.add !== null)
      ? AddCardOperation.fromPartial(object.add)
      : undefined;
    message.edit = (object.edit !== undefined && object.edit !== null)
      ? EditCardOperation.fromPartial(object.edit)
      : undefined;
    message.combine = (object.combine !== undefined && object.combine !== null)
      ? CombineCardsOperation.fromPartial(object.combine)
      : undefined;
    message.delete = (object.delete !== undefined && object.delete !== null)
      ? DeleteCardOperation.fromPartial(object.delete)
      : undefined;
    message.addLike = (object.addLike !== undefined && object.addLike !== null)
      ? AddLikeCardOperation.fromPartial(object.addLike)
      : undefined;
    message.removeLike = (object.removeLike !== undefined && object.removeLike !== null)
      ? RemoveLikeCardOperation.fromPartial(object.removeLike)
      : undefined;
    message.move = (object.move !== undefined && object.move !== null)
      ? MoveCardOperation.fromPartial(object.move)
      : undefined;
    return message;
  },
};

function createBaseStartTimerOperation(): StartTimerOperation {
  return { minutes: 0 };
}

export const StartTimerOperation: MessageFns<StartTimerOperation> = {
  encode(message: StartTimerOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minutes !== 0) {
      writer.uint32(8).int32(message.minutes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartTimerOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartTimerOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minutes = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartTimerOperation>): StartTimerOperation {
    return StartTimerOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartTimerOperation>): StartTimerOperation {
    const message = createBaseStartTimerOperation();
    message.minutes = object.minutes ?? 0;
    return message;
  },
};

function createBasePauseTimerOperation(): PauseTimerOperation {
  return {};
}

export const PauseTimerOperation: MessageFns<PauseTimerOperation> = {
  encode(_: PauseTimerOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseTimerOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseTimerOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PauseTimerOperation>): PauseTimerOperation {
    return PauseTimerOperation.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PauseTimerOperation>): PauseTimerOperation {
    const message = createBasePauseTimerOperation();
    return message;
  },
};

function createBaseStartVotingOperation(): StartVotingOperation {
  return { votesPerUser: 0, timerMinutes: 0 };
}

export const StartVotingOperation: MessageFns<StartVotingOperation> = {
  encode(message: StartVotingOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.votesPerUser !== 0) {
      writer.uint32(8).int32(message.votesPerUser);
    }
    if (message.timerMinutes !== 0) {
      writer.uint32(16).int32(message.timerMinutes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartVotingOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartVotingOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.votesPerUser = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timerMinutes = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StartVotingOperation>): StartVotingOperation {
    return StartVotingOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartVotingOperation>): StartVotingOperation {
    const message = createBaseStartVotingOperation();
    message.votesPerUser = object.votesPerUser ?? 0;
    message.timerMinutes = object.timerMinutes ?? 0;
    return message;
  },
};

function createBaseStopVotingOperation(): StopVotingOperation {
  return {};
}

export const StopVotingOperation: MessageFns<StopVotingOperation> = {
  encode(_: StopVotingOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopVotingOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopVotingOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<StopVotingOperation>): StopVotingOperation {
    return StopVotingOperation.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StopVotingOperation>): StopVotingOperation {
    const message = createBaseStopVotingOperation();
    return message;
  },
};

function createBaseAddCardOperation(): AddCardOperation {
  return { columnId: "", text: "" };
}

export const AddCardOperation: MessageFns<AddCardOperation> = {
  encode(message: AddCardOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.columnId !== "") {
      writer.uint32(10).string(message.columnId);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCardOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCardOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.columnId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AddCardOperation>): AddCardOperation {
    return AddCardOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddCardOperation>): AddCardOperation {
    const message = createBaseAddCardOperation();
    message.columnId = object.columnId ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseEditCardOperation(): EditCardOperation {
  return { cardId: "", text: "" };
}

export const EditCardOperation: MessageFns<EditCardOperation> = {
  encode(message: EditCardOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditCardOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditCardOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<EditCardOperation>): EditCardOperation {
    return EditCardOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EditCardOperation>): EditCardOperation {
    const message = createBaseEditCardOperation();
    message.cardId = object.cardId ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseCombineCardsOperation(): CombineCardsOperation {
  return { deleteCardId: "", targetCardId: "" };
}

export const CombineCardsOperation: MessageFns<CombineCardsOperation> = {
  encode(message: CombineCardsOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deleteCardId !== "") {
      writer.uint32(10).string(message.deleteCardId);
    }
    if (message.targetCardId !== "") {
      writer.uint32(18).string(message.targetCardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CombineCardsOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCombineCardsOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deleteCardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetCardId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CombineCardsOperation>): CombineCardsOperation {
    return CombineCardsOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CombineCardsOperation>): CombineCardsOperation {
    const message = createBaseCombineCardsOperation();
    message.deleteCardId = object.deleteCardId ?? "";
    message.targetCardId = object.targetCardId ?? "";
    return message;
  },
};

function createBaseDeleteCardOperation(): DeleteCardOperation {
  return { cardId: "" };
}

export const DeleteCardOperation: MessageFns<DeleteCardOperation> = {
  encode(message: DeleteCardOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCardOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCardOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteCardOperation>): DeleteCardOperation {
    return DeleteCardOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCardOperation>): DeleteCardOperation {
    const message = createBaseDeleteCardOperation();
    message.cardId = object.cardId ?? "";
    return message;
  },
};

function createBaseAddLikeCardOperation(): AddLikeCardOperation {
  return { cardId: "" };
}

export const AddLikeCardOperation: MessageFns<AddLikeCardOperation> = {
  encode(message: AddLikeCardOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddLikeCardOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddLikeCardOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AddLikeCardOperation>): AddLikeCardOperation {
    return AddLikeCardOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddLikeCardOperation>): AddLikeCardOperation {
    const message = createBaseAddLikeCardOperation();
    message.cardId = object.cardId ?? "";
    return message;
  },
};

function createBaseMoveCardOperation(): MoveCardOperation {
  return { cardId: "", newColumnId: "", newOrderId: 0 };
}

export const MoveCardOperation: MessageFns<MoveCardOperation> = {
  encode(message: MoveCardOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.newColumnId !== "") {
      writer.uint32(18).string(message.newColumnId);
    }
    if (message.newOrderId !== 0) {
      writer.uint32(24).int32(message.newOrderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveCardOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveCardOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newColumnId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newOrderId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MoveCardOperation>): MoveCardOperation {
    return MoveCardOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveCardOperation>): MoveCardOperation {
    const message = createBaseMoveCardOperation();
    message.cardId = object.cardId ?? "";
    message.newColumnId = object.newColumnId ?? "";
    message.newOrderId = object.newOrderId ?? 0;
    return message;
  },
};

function createBaseChangeCardOrderEvent(): ChangeCardOrderEvent {
  return { cardId: "", newOrderNumber: "" };
}

export const ChangeCardOrderEvent: MessageFns<ChangeCardOrderEvent> = {
  encode(message: ChangeCardOrderEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.newOrderNumber !== "") {
      writer.uint32(18).string(message.newOrderNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeCardOrderEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeCardOrderEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newOrderNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ChangeCardOrderEvent>): ChangeCardOrderEvent {
    return ChangeCardOrderEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeCardOrderEvent>): ChangeCardOrderEvent {
    const message = createBaseChangeCardOrderEvent();
    message.cardId = object.cardId ?? "";
    message.newOrderNumber = object.newOrderNumber ?? "";
    return message;
  },
};

function createBaseRemoveLikeCardOperation(): RemoveLikeCardOperation {
  return { cardId: "" };
}

export const RemoveLikeCardOperation: MessageFns<RemoveLikeCardOperation> = {
  encode(message: RemoveLikeCardOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveLikeCardOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveLikeCardOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<RemoveLikeCardOperation>): RemoveLikeCardOperation {
    return RemoveLikeCardOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveLikeCardOperation>): RemoveLikeCardOperation {
    const message = createBaseRemoveLikeCardOperation();
    message.cardId = object.cardId ?? "";
    return message;
  },
};

function createBaseGetRoomTemplatesResponse(): GetRoomTemplatesResponse {
  return { templateIds: [] };
}

export const GetRoomTemplatesResponse: MessageFns<GetRoomTemplatesResponse> = {
  encode(message: GetRoomTemplatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.templateIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRoomTemplatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRoomTemplatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.templateIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetRoomTemplatesResponse>): GetRoomTemplatesResponse {
    return GetRoomTemplatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRoomTemplatesResponse>): GetRoomTemplatesResponse {
    const message = createBaseGetRoomTemplatesResponse();
    message.templateIds = object.templateIds?.map((e) => e) || [];
    return message;
  },
};

export type ApiServiceDefinition = typeof ApiServiceDefinition;
export const ApiServiceDefinition = {
  name: "ApiService",
  fullName: "ApiService",
  methods: {
    activateUser: {
      name: "ActivateUser",
      requestType: Empty,
      requestStream: false,
      responseType: ActivateUserResponse,
      responseStream: false,
      options: {},
    },
    getUserStatus: {
      name: "GetUserStatus",
      requestType: Empty,
      requestStream: false,
      responseType: GetUserStatusResponse,
      responseStream: false,
      options: {},
    },
    getRoomTemplates: {
      name: "GetRoomTemplates",
      requestType: Empty,
      requestStream: false,
      responseType: GetRoomTemplatesResponse,
      responseStream: false,
      options: {},
    },
    initRoom: {
      name: "InitRoom",
      requestType: InitRoomRequest,
      requestStream: false,
      responseType: InitRoomResponse,
      responseStream: false,
      options: {},
    },
    getRoomInfo: {
      name: "GetRoomInfo",
      requestType: GetRoomInfoRequest,
      requestStream: false,
      responseType: GetRoomInfoResponse,
      responseStream: false,
      options: {},
    },
    connect: {
      name: "Connect",
      requestType: ConnectRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    invokeRoomOperation: {
      name: "InvokeRoomOperation",
      requestType: InvokeRoomOperationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface ApiServiceImplementation<CallContextExt = {}> {
  activateUser(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<ActivateUserResponse>>;
  getUserStatus(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<GetUserStatusResponse>>;
  getRoomTemplates(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetRoomTemplatesResponse>>;
  initRoom(request: InitRoomRequest, context: CallContext & CallContextExt): Promise<DeepPartial<InitRoomResponse>>;
  getRoomInfo(
    request: GetRoomInfoRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetRoomInfoResponse>>;
  connect(request: ConnectRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  invokeRoomOperation(
    request: InvokeRoomOperationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface ApiServiceClient<CallOptionsExt = {}> {
  activateUser(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<ActivateUserResponse>;
  getUserStatus(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<GetUserStatusResponse>;
  getRoomTemplates(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetRoomTemplatesResponse>;
  initRoom(request: DeepPartial<InitRoomRequest>, options?: CallOptions & CallOptionsExt): Promise<InitRoomResponse>;
  getRoomInfo(
    request: DeepPartial<GetRoomInfoRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetRoomInfoResponse>;
  connect(request: DeepPartial<ConnectRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  invokeRoomOperation(
    request: DeepPartial<InvokeRoomOperationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
